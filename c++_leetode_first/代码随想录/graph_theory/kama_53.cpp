//
// Created by 11818 on 2024/11/19.
//
//prim算法
//kama53.寻宝
//不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来。
//给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。

//输入描述
//第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V=2，一个有两个顶点，分别是1和2。
//接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。

//输出描述
//输出联通所有岛屿的最小路径总距离

//最小生成树
//最小生成树是所有节点的最小连通子图， 即：以最小的成本（边的权值）将图中所有节点链接到一起。
//图中有n个节点，那么一定可以用 n - 1 条边将所有节点连接到一起。
//图中有n个节点，那么一定可以用 n - 1 条边将所有节点连接到一起。


/**prim 算法：是从节点的角度 采用贪心的策略 每次寻找距离 最小生成树最近的节点 并加入到最小生成树中。*/

/**prim算法核心三部曲：
 * 1.选距离生成树的最近节点
 * 2.最近节点加入生成树
 * 3.更新非生成树节点到生成树的距离
 * */

/**
 * minDist数组是用来记录每一个节点距离最小生成树的最近距离
 * 1.初始化状态：minDist数组里的数值初始化为最大数。
 * 2.第一步：选距离生成树最近节点
 * 选择距离最小生成树最近的节点，加入到最小生成树，刚开始还没有最小生成树
 * 所以随便选一个节点加入就好（因为每一个节点一定会在最小生成树里，所以随便选一个就好），
 * 那我们选择节点1 （符合遍历数组的习惯，第一个遍历的也是节点1）
 * 3.第二步：最近节点加入生成树
 * 此时 节点1 已经算最小生成树的节点。
 * 3.第三步：更新非生成树节点到生成树的距离
 *
 * */

#include <climits>
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int v, e;
    int x, y, k;
    //V代表顶点数，E代表边数
    cin >> v >> e;
    //填写一个默认最大值，题目描述val最大为10000
    vector<vector<int>> grid(v + 1, vector<int>(v + 1, 10001));
    while (e--) {
        cin >> x >> y >> k;
        //因为是双向图所以两个方向都要填上
        grid[x][y] = k;
        grid[y][x] = k;
    }
    //所有节点到最小生成树的最小距离
    vector<int> minDist(v + 1, 10001);
    //这个节点是否在树里
    vector<bool> isInTree(v + 1, false);
    //我们只需要循环n - 1次，建立n - 1 条边，就可以把n个节点的图连接在一起
    for (int i = 1; i < v; i++) {//这里面的for对应的是加入的边部分
        //1.prim三部曲，第一步：选距离生成树的最近节点
        int cur = -1;//选中哪个节点，加入最小生成树
        int minVal = INT_MAX;
        for (int j = 1; j <= v; j++) {
            //1-v顶点编号，这里下标从1开始
            //选取最小生成树的条件：
            //1.不在最小生成树里
            //2.距离最小生成树最近的节点
            if (!isInTree[j] && minDist[j] < minVal) {
                minVal = minDist[j];
                cur = j;
            }
        }
        //2.prim三部曲：第二步：最近节点cur加入生成树
        isInTree[cur] = true;
        //3.第三步：更新非生成树节点到生成树的距离
        //cur节点加入后，最小生成树加入新节点，那么所有的节点到最小生成树的距离更新一下
        //由于cur节点最新加入到最小生成树，那么只需要关心与cur相连的非生成树节点的距离是否比原来的非生成树节点到生成树节点的距离更小
        for (int j = 1; j <= v; j++) {
            //更新条件：
            //1.节点是非生成树的节点
            //2.与cur相连的节点的权值比该某节点距离最小生成树的距离小
            if (!isInTree[j] && grid[cur][j] < minDist[j]) {
                minDist[j] = grid[cur][j];
            }
        }
    }
    int result = 0;
    for (int i = 2; i <= v; i++) {
        result += minDist[i];
    }
    cout << result << endl;
    return 0;
}